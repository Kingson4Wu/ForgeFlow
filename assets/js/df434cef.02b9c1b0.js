"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[7752],{9888:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"forgeflow-engineering-grade-automation","metadata":{"permalink":"/ForgeFlow/blog/forgeflow-engineering-grade-automation","editUrl":"https://github.com/kingson4wu/ForgeFlow/edit/main/documentation/blog/2025-09-16-forgeflow-engineering-grade-automation.md","source":"@site/blog/2025-09-16-forgeflow-engineering-grade-automation.md","title":"FORGEFLOW: Engineering-Grade Automation for AI CLIs Inside Tmux","description":"Comprehensive guide to ForgeFlow - an engineering-grade automation tool that drives AI CLI tools (Qwen, Gemini, Claude) inside tmux sessions with configurable rules.","date":"2025-09-16T00:00:00.000Z","tags":[{"inline":false,"label":"AI","permalink":"/ForgeFlow/blog/tags/ai","description":"Posts about AI automation and tools"},{"inline":false,"label":"Automation","permalink":"/ForgeFlow/blog/tags/automation","description":"Posts about automation workflows and tools"},{"inline":false,"label":"Tmux","permalink":"/ForgeFlow/blog/tags/tmux","description":"Posts about tmux and terminal automation"},{"inline":false,"label":"CLI","permalink":"/ForgeFlow/blog/tags/cli","description":"Posts about command-line interface tools"},{"inline":false,"label":"ForgeFlow","permalink":"/ForgeFlow/blog/tags/forgeflow","description":"Posts specifically about the ForgeFlow tool"},{"inline":false,"label":"Development","permalink":"/ForgeFlow/blog/tags/development","description":"Posts about development practices and tools"}],"readingTime":4.13,"hasTruncateMarker":true,"authors":[{"name":"Kingson Wu","title":"Creator of ForgeFlow","url":"https://github.com/kingson4wu","page":null,"socials":{"github":"https://github.com/kingson4wu","devto":"https://dev.to/kingson4ng"},"imageURL":"https://github.com/kingson4wu.png","key":"kingsonwu"}],"frontMatter":{"slug":"forgeflow-engineering-grade-automation","title":"FORGEFLOW: Engineering-Grade Automation for AI CLIs Inside Tmux","authors":["kingsonwu"],"tags":["ai","automation","tmux","cli","forgeflow","development"],"description":"Comprehensive guide to ForgeFlow - an engineering-grade automation tool that drives AI CLI tools (Qwen, Gemini, Claude) inside tmux sessions with configurable rules."},"unlisted":false,"nextItem":{"title":"Tmux Inner Network Tunneling: Simple Remote Development","permalink":"/ForgeFlow/blog/tmux-inner-network-tunneling-for-remote-development"}},"content":"ForgeFlow automates interactive AI CLIs (e.g., Qwen, Gemini, Claude) inside a tmux session using a clean \\"adapter + rules\\" architecture. It detects prompts and processing states, sends the right commands, and keeps going until tasks converge \u2014 with logs, extensibility, and sensible recovery behavior.\\n\\n\x3c!-- truncate --\x3e\\n\\n## This guide covers:\\n\\n- How to install and use ForgeFlow (focus)\\n- Architecture overview, key interfaces, and ANSI support\\n- Extending with custom rules and adapters\\n- A simple flow diagram in Markdown\\n\\n## Who It\'s For\\n\\n- Developers who live in the terminal and use AI CLIs\\n- Teams that want a repeatable driver for long-running, iterative tasks\\n- Anyone who needs logging and simple extensibility without reinventing the loop\\n\\n## Requirements\\n\\n- macOS/Linux\\n- Python 3.9+\\n- tmux installed and on PATH\\n\\n## Install And Run\\n\\n- Dev install (pinned tooling):\\n  - `pip install -e .[dev] -c constraints-dev.txt`\\n- Runtime install:\\n  - `pip install -e .`\\n- Makefile helpers:\\n  - `make dev-install` \u2014 install dev deps with constraints\\n  - `make lint` / `make fmt` / `make test`\\n  - `make setup-hooks` \u2014 optional Git hooks\\n- Typical run:\\n\\n```bash\\nforgeflow \\\\\\n--session qwen_session \\\\\\n--workdir \\"/abs/path/to/your/project\\" \\\\\\n--ai-cmd \\"qwen --proxy http://localhost:7890 --yolo\\" \\\\\\n--cli-type qwen \\\\\\n--poll 10 \\\\\\n--timeout 2000 \\\\\\n--log-level INFO \\\\\\n--log-file forgeflow.log\\n```\\n\\n- Switch adapters:\\n  - `--cli-type qwen` or `--cli-type gemini` (claude_code is a placeholder)\\n- Use project-specific rules:\\n  - Add `{project}_rules.py` or `{project}.py` in your project root or in examples/\\n  - Run with `--project myproject`\\n\\n```bash\\nforgeflow \\\\\\n--session qwen_session \\\\\\n--workdir \\"/abs/path/to/your/project\\" \\\\\\n--ai-cmd \\"qwen --proxy http://localhost:7890 --yolo\\" \\\\\\n--project myproject \\\\\\n--cli-type qwen\\n```\\n\\n- Logging:\\n  - `--log-file forgeflow.log` writes file logs\\n  - `--no-console` disables console logging\\n  - `--log-level` supports DEBUG/INFO/WARNING/ERROR\\n\\n## Python API\\n\\n```python\\nfrom forgeflow.core.automation import Config, run_automation\\n\\ncfg = Config(\\n    session=\\"qwen_session\\",\\n    workdir=\\"/abs/path/to/your/project\\",\\n    ai_cmd=\\"qwen --proxy http://localhost:7890 --yolo\\",\\n    cli_type=\\"qwen\\",\\n    poll_interval=10,\\n    input_prompt_timeout=2000,\\n    log_file=\\"forgeflow.log\\",\\n    log_to_console=True,\\n    project=\\"myproject\\",   # optional\\n    log_level=\\"INFO\\",\\n)\\nrun_automation(cfg)\\n```\\n\\n## Rules: Project-Level Customization\\n\\n- File naming:\\n  - `{project}_rules.py` or `{project}.py`\\n- Function name (recommended):\\n  - `build_rules()` -> `list[Rule]`\\n- Minimal example:\\n\\n```python\\n# examples/myproject_rules.py\\n\\nfrom forgeflow.core.rules import Rule\\n\\ndef build_rules() -> list[Rule]:\\n    def done(output: str) -> bool:\\n        return \\"All tasks have been completed.\\" in output\\n\\n    return [\\n        Rule(check=done, command=None),  # stop\\n        Rule(check=lambda out: \\"API Error\\" in out, command=\\"continue\\"),\\n        Rule(check=lambda out: True, command=\\"continue\\"),\\n    ]\\n```\\n\\n- Rule behavior:\\n  - Rules are evaluated in order, the first matching rule returns its command.\\n  - If command is None, automation stops.\\n\\n## Architecture Overview\\n\\n- Core loop (`forgeflow/core/automation.py`)\\n  - Creates/attaches tmux session\\n  - Determines adapter by `--cli-type`\\n  - Captures tmux output, checks \\"prompt vs. processing\\", evaluates rules\\n  - Timeout recovery: ESC \u2192 progressive Backspace until prompt \u2192 send continue\\n  - Logging level configurable; file and console outputs supported\\n- tmux I/O (`forgeflow/core/tmux_ctl.py`)\\n  - Encapsulates tmux operations: session creation, send keys, capture pane\\n  - `capture_output(include_ansi=False)` supports capturing raw ANSI when needed\\n- Adapters (`forgeflow/core/cli_adapters/*`)\\n  - Interface `CLIAdapter`:\\n    - `is_input_prompt(output)` -> `bool`\\n    - `is_input_prompt_with_text(output)` -> `bool`\\n    - `is_task_processing(output)` -> `bool`\\n    - `is_ai_cli_exist(output)` -> `bool`\\n    - `wants_ansi()` -> `bool` \u2014 ask automation to capture pane with ANSI codes\\n  - Implementations: `qwen.py`, `gemini.py` (claude_code placeholder present)\\n  - Adapter resolution via `get_cli_adapter(cli_type)`\\n- Rules (`forgeflow/core/rules.py`)\\n  - `Rule(check: Callable[[str], bool], command: str | None)`\\n  - Default rules and `next_command(output, rules)`\\n- Rule loader (`forgeflow/core/rule_loader.py`)\\n  - Dynamically loads `{project}_rules.py` or `{project}.py` from workdir or examples/\\n\\n## ANSI Utilities For Smarter Detection\\n\\nSome CLIs render distinct prompt colors or attributes. You can opt-in to capture ANSI and parse it in your adapter:\\n\\n- Adapter opt-in:\\n\\n```python\\ndef wants_ansi(self) -> bool:\\n    return True\\n```\\n\\n- Utilities (`forgeflow/core/ansi.py`):\\n  - `strip_ansi(text)` -> `str` \u2014 removes all ANSI escape sequences\\n  - `parse_ansi_segments(text)` -> `list[Segment]`\\n    - Splits text into styled segments (tracks SGR attributes)\\n    - Supports bold, dim, italic, underline, blink, inverse, strike\\n    - Supports FG/BG basic (30\u201337/90\u201397/40\u201347/100\u2013107), 256-color, truecolor\\n  - `split_segments_lines(segments)` -> `list[list[Segment]]`\\n    - Split by newline while preserving styles\\n- Example usage in an adapter:\\n\\n```python\\nfrom forgeflow.core.ansi import parse_ansi_segments\\n\\nclass MyAdapter(CLIAdapter):\\n    def wants_ansi(self) -> bool:\\n        return True\\n\\n    def is_input_prompt(self, output: str) -> bool:\\n        # Example heuristic: find a red prompt marker at end of screen\\n        segments = parse_ansi_segments(output)\\n        text = \'\'.join(seg.text for seg in segments)\\n        return text.rstrip().endswith(\'>\')  # combine with color checks if needed\\n```\\n\\nThis keeps default behavior unchanged while enabling color-aware rules when helpful.\\n\\n## Simple Flow Diagram\\n\\n```mermaid\\nflowchart TD\\n    A[Start forgeflow] --\x3e B[Create/attach tmux session]\\n    B --\x3e C[Ensure AI CLI running]\\n    C --\x3e D{Capture output<br/>(ANSI optional)}\\n    D --\x3e |prompt & idle| E[Evaluate rules -> command]\\n    E --\x3e F[Send text + Enter]\\n    F --\x3e G[Sleep 2s]\\n    G --\x3e D\\n    D --\x3e |prompt has text| H[Send Enter]\\n    H --\x3e G\\n    D --\x3e |processing| I[Wait poll interval]\\n    I --\x3e D\\n    D --\x3e |timeout| J[ESC + progressive backspace]\\n    J --\x3e K[Send \\"continue\\"]\\n    K --\x3e D\\n    E --\x3e |None| L[Stop]\\n```\\n\\n## Troubleshooting\\n\\n- \\"tmux is required but not found\\"\\n  - Install tmux and ensure `tmux -V` succeeds\\n- CLI not detected as running\\n  - Check `--ai-cmd` and allow a few seconds post-launch\\n- No project rules\\n  - Defaults are used; add custom rules for better convergence\\n\\n## Repository And License\\n\\n- Repo: https://github.com/kingson4wu/ForgeFlow\\n- License: MIT"},{"id":"tmux-inner-network-tunneling-for-remote-development","metadata":{"permalink":"/ForgeFlow/blog/tmux-inner-network-tunneling-for-remote-development","editUrl":"https://github.com/kingson4wu/ForgeFlow/edit/main/documentation/blog/2025-08-28-tmux-inner-network-tunneling-for-remote-development.md","source":"@site/blog/2025-08-28-tmux-inner-network-tunneling-for-remote-development.md","title":"Tmux Inner Network Tunneling: Simple Remote Development","description":"Simple guide to using tmux with SSH tunneling for persistent remote development sessions.","date":"2025-08-28T00:00:00.000Z","tags":[{"inline":false,"label":"Tmux","permalink":"/ForgeFlow/blog/tags/tmux","description":"Posts about tmux and terminal automation"},{"inline":true,"label":"tunneling","permalink":"/ForgeFlow/blog/tags/tunneling"},{"inline":true,"label":"remote-development","permalink":"/ForgeFlow/blog/tags/remote-development"},{"inline":true,"label":"networking","permalink":"/ForgeFlow/blog/tags/networking"},{"inline":true,"label":"ssh","permalink":"/ForgeFlow/blog/tags/ssh"}],"readingTime":1.67,"hasTruncateMarker":false,"authors":[{"name":"Kingson Wu","title":"Creator of ForgeFlow","url":"https://github.com/kingson4wu","page":null,"socials":{"github":"https://github.com/kingson4wu","devto":"https://dev.to/kingson4ng"},"imageURL":"https://github.com/kingson4wu.png","key":"kingsonwu"}],"frontMatter":{"slug":"tmux-inner-network-tunneling-for-remote-development","title":"Tmux Inner Network Tunneling: Simple Remote Development","authors":["kingsonwu"],"tags":["tmux","tunneling","remote-development","networking","ssh"],"description":"Simple guide to using tmux with SSH tunneling for persistent remote development sessions."},"unlisted":false,"prevItem":{"title":"FORGEFLOW: Engineering-Grade Automation for AI CLIs Inside Tmux","permalink":"/ForgeFlow/blog/forgeflow-engineering-grade-automation"}},"content":"Tmux inner network tunneling is a technique that combines tmux\'s session persistence with SSH tunneling to create stable remote development connections. This approach allows you to maintain persistent development sessions that survive network disconnections.\\n\\n## Core Principle\\n\\nThe key insight is simple:\\n- **tmux** maintains persistent terminal sessions even when SSH connections drop\\n- **SSH tunneling** creates secure pathways to access internal services\\n- Together, they enable reliable remote development from anywhere\\n\\n## Basic Setup\\n\\n1. Install SSH and tmux on your target machine\\n2. Set up tunneling tools (like Cloudflare Tunnel, frp, or ZeroTier) to expose SSH service\\n3. Create persistent tmux sessions to hold your work environment\\n\\n```bash\\n# Create a persistent session\\ntmux new-session -d -s remote_dev\\n\\n# Attach to the session from anywhere\\ntmux attach -t remote_dev\\n```\\n\\n## SSH Tunneling with tmux\\n\\nCreate a dedicated session for managing tunnels:\\n\\n```bash\\n# Create a tunnel management session\\ntmux new-session -d -s tunnels\\n\\n# Start SSH port forwarding (forward local port 8080 to remote port 8080)\\ntmux send-keys -t tunnels \'ssh -L 8080:localhost:8080 user@remote-server -N\' Enter\\n\\n# Add more tunnels as needed\\ntmux split-window -h -t tunnels\\ntmux send-keys -t tunnels \'ssh -L 3306:localhost:3306 user@db-server -N\' Enter\\n```\\n\\n## Why This Works\\n\\n- When your SSH connection drops, the tmux session remains active on the remote machine\\n- You can reconnect to the same session later and pick up exactly where you left off\\n- Multiple tunnels can be managed within organized tmux windows\\n- Development workflow stays uninterrupted despite network changes\\n\\n## Quick Start\\n\\n1. Set up SSH access to your development machine\\n2. Install and configure a tunneling solution (Cloudflare Tunnel, frp, etc.)\\n3. Create a persistent tmux session before disconnecting:\\n\\n```bash\\ntmux new-session -d -s mydev -c ~\\n```\\n\\n4. Connect from anywhere and resume work:\\n\\n```bash\\ntmux attach -t mydev\\n```\\n\\n## Conclusion\\n\\nTmux inner network tunneling simplifies remote development by combining session persistence with secure tunneling. This approach eliminates the complexity of managing multiple connections while ensuring work is never lost due to network interruptions."}]}}')}}]);